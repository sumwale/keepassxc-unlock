#!/bin/bash

set -e
set -o pipefail

# ensure that only system paths are searched for all the utilities
export PATH="/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/sbin:/usr/local/bin"

SCRIPT="$(basename "${BASH_SOURCE[0]}")"

function usage() {
  echo
  echo "Usage: $SCRIPT <USER>"
  echo
  echo "Monitor a user for login and screen unlock events to unlock configured KeepassXC databases"
  echo
  echo "Arguments:"
  echo "  <USER>          user name or ID to be monitored"
  echo
}

if [ "$#" -ne 1 ]; then
  usage
  exit 1
fi

if [ $(id -u) -ne 0 ]; then
  echo This utility must be run as root
  exit 1
fi

user_id=$(id -u "$1")
[ -z "$user_id" ] && exit 1

user_conf_dir=/etc/keepassxc-unlock/$user_id
if ! compgen -G "$user_conf_dir/*.conf" >/dev/null; then
  echo "No configuration found for $user_id -- run keepassxc-unlock-setup first"
  exit 0
fi

function do_unlock() {
  user_id=$1
  user_conf_dir=$2
  selected_session=$3
  wait_secs=$4

  # skip unlock if LockedHint is true
  if gdbus call -y -d org.freedesktop.login1 -o $selected_session -m \
      org.freedesktop.DBus.Properties.Get org.freedesktop.login1.Session LockedHint | \
      grep -qw true; then
    echo "Skipping unlock since screen/session is still locked!"
    return 0
  fi

  DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$user_id/bus"
  for conf_file in $(compgen -G "$user_conf_dir/*.conf"); do
    conf_name=$(basename "$conf_file" .conf)
    enc_pwd=
    while read -r line; do
      case "$line" in
        DB=*)
          kdbx_file="${line#DB=}"
          ;;
        KEY=*)
          key_file="${line#KEY=}"
          ;;
        PASSWORD:)
          ;;
        *)
          enc_pwd="$enc_pwd$line\n"
          ;;
      esac
    done < $conf_file
    passwd=$(echo -ne "$enc_pwd" | systemd-creds --name=$conf_name decrypt - -)
    for i in $(seq $wait_secs); do
      if sudo -u "#$user_id" env DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION_BUS_ADDRESS" \
          dbus-send --session --print-reply --dest=org.keepassxc.KeePassXC.MainWindow \
          /keepassxc org.keepassxc.KeePassXC.MainWindow.openDatabase "string:$kdbx_file" \
          "string:$passwd" "string:$key_file" 2>/dev/null >/dev/null; then
        break
      fi
      sleep 1
    done
    passwd=
    enc_pwd=
  done
}

# pick the first x11/wayland session as the one to be monitored, else exit if none found
function select_session() {
  user_id=$1
  gdbus introspect -y -d org.freedesktop.login1 -o /org/freedesktop/login1/session -r -p | \
    awk '{
      if (!selected_session) {
        if ($1 == "node" && $2 ~ /^.org.freedesktop.login1.session.[0-9_]+$/) {
          session_path = $2
          session_valid = 1
        } else if (session_path && session_valid) {
          if ($3 == "User" && $5 !~ /^\('$user_id',$/) {
            session_valid = 0
          } else if ($3 == "Remote" && $5 == "true") {
            session_valid = 0
          } else if ($3 == "Type" && $5 !~ /x11|wayland/) {
            session_valid = 0
          } else if ($1 == "};") {
            selected_session = session_path
            session_path = ""
          }
        }
      }
    } END {
      printf "%s", selected_session
    }'
}

# wait for sometime for session to be created
for i in $(seq 30); do
  selected_session=$(select_session $user_id)
  if [ -n "$selected_session" ]; then
    break
  fi
  sleep 1
done
if [ -z "$selected_session" ]; then
  echo "No valid X11/Wayland session found for UID=$user_id"
  exit 0
fi

# unlock on startup which should happen in PAM post successful auth
echo "Startup: unlocking registered KeePassXC database(s) for UID=$user_id"
do_unlock $user_id $user_conf_dir $selected_session 60

echo Monitoring session $selected_session for UID=$user_id

session_locked=false
session_active=true
while read -r event; do
  if [[ "$event" =~ ^$selected_session:.*LockedHint[^:]*:[[:space:]]*.(true|false).*$ ]]; then
    if [ "$session_locked" = true -a "${BASH_REMATCH[1]}" = false ]; then
      echo "Unlocking database(s) after screen/session unlock event"
      do_unlock $user_id $user_conf_dir $selected_session 10 &
    fi
    session_locked=${BASH_REMATCH[1]}
  elif [[ "$event" =~ ^$selected_session:.*Active[^:]*:[[:space:]]*.(true|false).*$ ]]; then
    if [ "$session_locked" = false -a "$session_active" = false -a "${BASH_REMATCH[1]}" = true ]; then
      echo "Unlocking database(s) after session activation event"
      do_unlock $user_id $user_conf_dir $selected_session 30
    fi
    session_active=${BASH_REMATCH[1]}
  elif [[ "$event" =~ ^/org/freedesktop/login1:[[:space:]]*org.freedesktop.login1.Manager.SessionRemoved.*$selected_session[^0-9_] ]]; then
    echo "Ending session $selected_session for UID=$user_id"
    exit 0
  fi
done < <(gdbus monitor -y -d org.freedesktop.login1)
